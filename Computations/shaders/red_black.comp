#version 460 core

#ifndef _CONFIGURED
	#define _WORKGROUP_X 16
	#define _WORKGROUP_Y 16
#endif

#define WORKGROUP_X _WORKGROUP_X
#define WORKGROUP_Y _WORKGROUP_Y
#define WORKGROUP ivec2(WORKGROUP_X, WORKGROUP_Y)

#define TRUE_WORKGROUP_X (WORKGROUP_X + 2)
#define TRUE_WORKGROUP_Y (WORKGROUP_Y + 2)
#define TRUE_WORKGROUP ivec2(TRUE_WORKGROUP_X, TRUE_WORKGROUP_Y)

layout(local_size_x = WORKGROUP_X + 2, local_size_y = WORKGROUP_Y + 2) in;

// used both for read and write, boundary is not calculated
layout(binding = 0, r32f) uniform restrict image2D solution;
layout(binding = 1, r32f) uniform restrict readonly image2D f;

uniform int rb;
uniform float w;
uniform float hx;
uniform float hy;

#define CACHE_X (TRUE_WORKGROUP_X + 2)
#define CACHE_Y (TRUE_WORKGROUP_Y + 2)
#define CACHE_SIZE (CACHE_X * CACHE_Y)

// first is x, second is y
shared float cache[CACHE_SIZE];

int cacheFlatIndex(ivec2 indices)
{
	return indices.x * CACHE_Y + indices.y + (CACHE_Y + 1);
}

float cacheLoadValue(ivec2 indices)
{
	return cache[cacheFlatIndex(indices)];
}

void cacheStoreValue(ivec2 indices, float value)
{
	cache[cacheFlatIndex(indices)] = value;
}

// returns local index(zero-based), global(can be out of bounds) 
void getGlobalLocalInvocationID(out ivec2 global, out ivec2 local)
{
	ivec2 work = ivec2(gl_WorkGroupID.xy);

	local = ivec2(gl_LocalInvocationID.xy);
	global = local - 1 + work * WORKGROUP;
}

bool onBoundary(ivec2 global, ivec2 size)
{
	return any(equal(global, ivec2(0))) || any(equal(global, size - 1)); 
}

bool inRegion(ivec2 coords, ivec2 start, ivec2 end)
{
	return all(lessThanEqual(start, coords)) && all(lessThan(coords, end));
}

bool inBounds(ivec2 global, ivec2 size)
{
	return inRegion(global, ivec2(0), size);
}

// red-black update
float update(float u00, float um10, float u10, float u0m1, float u01, float f00)
{
	float hxhx = hx * hx;
	float hyhy = hy * hy;
	float H = -2.0 / hxhx - 2.0 / hyhy;
	float u = f00 / H - (um10 + u10) / (hxhx * H) - (u0m1 + u01) / (hyhy * H);

	return (1.0 - w) * u00 + w * u;
}

void main()
{
	ivec2 global, local;
	getGlobalLocalInvocationID(global, local);

	ivec2 size = imageSize(solution);

	bool updateable = inRegion(global, ivec2(1), size - 1)
		&& inRegion(local, ivec2(1), TRUE_WORKGROUP - 1)
		&& (global.x + global.y & 0x1) != rb;

	float f00 = imageLoad(f, global).x;

	float u00 = imageLoad(solution, global).x;
	cacheStoreValue(local, u00);
	barrier();

	float um10 = cacheLoadValue(local + ivec2(-1, 0));
	float u10  = cacheLoadValue(local + ivec2(+1, 0));
	float u0m1 = cacheLoadValue(local + ivec2(0, -1));
	float u01  = cacheLoadValue(local + ivec2(0, +1));

	if (updateable) {
	u00 = update(u00, um10, u10, u0m1, u01, f00);
		imageStore(solution, global, vec4(u00));
	}
}