#version 460 core

#define STAGE 0

#define STEPS 2

#define TRUE_STEPS (2 * STEPS)

#define WORKGROUP_X 8
#define WORKGROUP_Y 8
#define WORKGROUP ivec2(WORKGROUP_X, WORKGROUP_Y)

#define TRUE_WORKGROUP_X (2 * WORKGROUP_X)
#define TRUE_WORKGROUP_Y (2 * WORKGROUP_Y)
#define TRUE_WORKGROUP ivec2(TRUE_WORKGROUP_X, TRUE_WORKGROUP_Y)

#define WORKGROUP_X_OVERLAP (WORKGROUP_X + STEPS * 2)
#define WORKGROUP_Y_OVERLAP (WORKGROUP_Y + STEPS * 2)
#define WORKGROUP_OVERLAP ivec2(WORKGROUP_X_OVERLAP, WORKGROUP_Y_OVERLAP)

#define TRUE_WORKGROUP_X_OVERLAP (2 * WORKGROUP_X_OVERLAP)
#define TRUE_WORKGROUP_Y_OVERLAP (2 * WORKGROUP_Y_OVERLAP)
#define TRUE_WORKGROUP_OVERLAP ivec2(TRUE_WORKGROUP_X_OVERLAP, TRUE_WORKGROUP_Y_OVERLAP)

// work should be dispatched flattened and equal to (WX * WY) / 2 (+- 1 if odd) like this (total_workgroups, 1, 1)
layout(local_size_x = WORKGROUP_X + STEPS * 2, local_size_y = WORKGROUP_Y + STEPS * 2) in;

#define CACHE_X (TRUE_WORKGROUP_X_OVERLAP + 2)
#define CACHE_Y (TRUE_WORKGROUP_Y_OVERLAP + 2)
#define CACHE_SIZE (CACHE_Y * CACHE_X)

// picture is stored in a row-major manner
// used both for read and write, boundary is not calculated
layout(binding = 0, r32f) uniform image2D solution[2];
layout(binding = 2, r32f) uniform readonly image2D f;

uniform int curr; // 0 or 1
uniform float w;
uniform float hx;
uniform float hy;
uniform int numWorkgroupsX; // num of workgroups along x-axis
uniform int numWorkgroupsY; // num of workgroups along y-axis

// first is x(i), second is y(j)
shared float cache[CACHE_SIZE];

int cacheFlatIndex(ivec2 indices)
{
	return indices.x * CACHE_Y + indices.y + (CACHE_Y + 1);
}

float cacheLoadValue(ivec2 indices)
{
	return cache[cacheFlatIndex(indices)];
}

void cacheStoreValue(ivec2 indices, float value)
{
	cache[cacheFlatIndex(indices)] = value;
}

// recalculate workgroup id (checkerboard pattern)
void getWorkgroupID(out ivec2 work)
{
	work.y = 2 * (int(gl_WorkGroupID.x) / numWorkgroupsX);
	work.x = int(gl_WorkGroupID.x) % numWorkgroupsX;
	work.y += (work.x + STAGE) % 2;
}

// returns local index(zero-based), global(can be out of bounds)
void getGlobalLocalInvocationID(in ivec2 work, out ivec2 global, out ivec2 local)
{
	local = 2 * ivec2(gl_LocalInvocationID.xy);
	global = local + work * TRUE_WORKGROUP - TRUE_STEPS;
}

// step function, in fact return signed distance to the frame defined by start coord and end coord
int stepFunction(ivec2 coord, ivec2 start, ivec2 end)
{
	ivec2 dc1 = coord - start;
	ivec2 dc2 = end - coord;
	return min(min(dc1.x, dc1.y), min(dc2.x, dc2.y));
}

int getCurrStep()
{
	int dx1 = int(gl_LocalInvocationID.x);
	int dy1 = int(gl_LocalInvocationID.y);
	int dx2 = (WORKGROUP_X_OVERLAP - 1) - dx1;
	int dy2 = (WORKGROUP_Y_OVERLAP - 1) - dy1;
	return min(min(dx1, dy1), min(dx2, dy2));
}

bool inRegion(ivec2 coords, ivec2 start, ivec2 end)
{
	return all(lessThanEqual(start, coords)) && all(lessThan(coords, end));
}

bool inBounds(ivec2 global, ivec2 size)
{
	return inRegion(global, ivec2(0), size);
}

bool onBoundary(ivec2 global, ivec2 size)
{
	return any(equal(global, ivec2(0))) || any(equal(global, size - 1)); 
}

bool shouldStore(ivec2 work)
{
	int X = WORKGROUP_X;
	int Y = WORKGROUP_Y;
	int S = STEPS;
	ivec2 p = ivec2(gl_LocalInvocationID.xy);
	ivec2 W = ivec2(numWorkgroupsX, numWorkgroupsY);

	int x;
	int y;
	int y0;
	int y1;

	// x case
	if (p.y < S) { // bottom, base: (S, S - 1)
		x = p.y - S + 1;
		y = p.x - S;
		y0 = x - 1;     // default line
		y1 = y - 1 - x; // default line
		if (work.x == 0) {
			y0 = -1;
		}
		if (work.x == W.x - 1) {
			y1 = X;
		}
		return y0 < y && y < y1;
	}
	else if (p.y >= S + Y) { // top, base: (S + X - 1, S + Y)
		x = p.y - S - Y;
		y = p.x - S - X + 1;
		y0 = x - 1;     // default line
		y1 = y - 1 - x; // default line
		if (work.x == 0) {
			y1 = X;
		}
		if (work.x == W.x - 1) {
			y0 = -1;
		}
		return y0 < y && y < y1;
	}

	// y case
	if (p.x < S) { // left, base: (S - 1, S + Y - 1)
		x = p.x - S + 1;
		y = p.y - S - Y + 1;
		y0 = x - 1;     // default line
		y1 = y - 1 - x; // default line
		if (work.y == 0) {
			y1 = Y;
		}
		if (work.y == W.y - 1) {
			y0 = -1;
		}
		return y0 < y && y < y1;
	}
	else if (p.x >= S + X) { // right, base: (S + X, S)
		x = p.x - S - X;
		y = p.y - S;
		y0 = x - 1;     // default line
		y1 = y - 1 - x; // default line
		if (work.y == 0) {
			y0 = -1;
		}
		if (work.y == W.y - 1) {
			y1 = Y;
		}
		return y0 < y && y < y1;
	}

	return false;
}

// red-black step
float update(float u00, float um10, float u10, float u0m1, float u01, float f00)
{
	float hxhx = hx * hx;
	float hyhy = hy * hy;
	float H = -2.0 / hxhx - 2.0 / hyhy;
	float u = f00 / H - (um10 + u10) / (hxhx * H) - (u0m1 + u01) / (hyhy * H);

	return (1.0 - w) * u00 + w * u;
}

void main()
{
	// some invocation's parameters
	ivec2 work, global, local;
	getWorkgroupID(work);
	getGlobalLocalInvocationID(work, global, local);

	ivec2 size = imageSize(solution[curr]);

	bool u00Updateable = inBounds(global              , size) && !onBoundary(global              , size);
	bool u10Updateable = inBounds(global + ivec2(1, 0), size) && !onBoundary(global + ivec2(1, 0), size);
	bool u01Updateable = inBounds(global + ivec2(0, 1), size) && !onBoundary(global + ivec2(0, 1), size);
	bool u11Updateable = inBounds(global + ivec2(1, 1), size) && !onBoundary(global + ivec2(1, 1), size);

	int steps = (inBounds(global, size) ? getCurrStep() : -1);

	// cache data
	float f01, f11;
	float f00, f10;

	// loads either value or zero if out of bounds
	f00 = imageLoad(f, global              ).x; 
	f10 = imageLoad(f, global + ivec2(1, 0)).x;
	f01 = imageLoad(f, global + ivec2(0, 1)).x;
	f11 = imageLoad(f, global + ivec2(1, 1)).x;

	float u01, u11;
	float u00, u10;

	// loads either value or zero if out of bounds
	u00 = imageLoad(solution[curr], global              ).x;
	u10 = imageLoad(solution[curr], global + ivec2(1, 0)).x;
	u01 = imageLoad(solution[curr], global + ivec2(0, 1)).x;
	u11 = imageLoad(solution[curr], global + ivec2(1, 1)).x;

	if (steps >= 0) {
		cacheStoreValue(local              , u00);
		cacheStoreValue(local + ivec2(1, 0), u10);
		cacheStoreValue(local + ivec2(0, 1), u01);
		cacheStoreValue(local + ivec2(1, 1), u11);
	}
	barrier();
	memoryBarrierShared();
	
	// computations	
	for (int i = 1; i <= STEPS; i++, steps--) {	
		// black update
		float u20  = cacheLoadValue(local + ivec2(2,  0)); // right
		float u1m1 = cacheLoadValue(local + ivec2(1, -1)); // bottom

		float u02  = cacheLoadValue(local + ivec2( 0, 2)); // top
		float um11 = cacheLoadValue(local + ivec2(-1, 1)); // left

		if (steps >= 0) {
			float u10_new = update(u10, u00, u20, u1m1, u11, f10);
			if (u10Updateable) {
				u10 = u10_new;
			}
			cacheStoreValue(local + ivec2(1, 0), u10);

			float u01_new = update(u01, um11, u11, u00, u02, f01);
			if (u01Updateable) {
				u01 = u01_new;
			}
			cacheStoreValue(local + ivec2(0, 1), u01);
		}
		barrier();
		memoryBarrierShared();

		// red update
		float u0m1 = cacheLoadValue(local + ivec2( 0, -1)); // bottom
		float um10 = cacheLoadValue(local + ivec2(-1,  0)); // left

		float u12 = cacheLoadValue(local + ivec2(1, 2)); // top
		float u21 = cacheLoadValue(local + ivec2(2, 1)); // right

		if (steps > 0)	{
			float u00_new = update(u00, um10, u10, u0m1, u01, f00);
			if (u00Updateable) {
				u00 = u00_new;
			}
			cacheStoreValue(local + ivec2(0, 0), u00);

			float u11_new = update(u11, u01, u21, u10, u12, f11);
			if (u11Updateable) {
				u11 = u11_new;
			}
			cacheStoreValue(local + ivec2(1, 1), u11);
		}
		barrier();
		memoryBarrierShared();
	}
	
	if (steps >= 0 || shouldStore(work)) {
		imageStore(solution[curr ^ 1], global              , vec4(cacheLoadValue(local              )));
		imageStore(solution[curr ^ 1], global + ivec2(1, 0), vec4(cacheLoadValue(local + ivec2(1, 0))));
		imageStore(solution[curr ^ 1], global + ivec2(0, 1), vec4(cacheLoadValue(local + ivec2(0, 1))));
		imageStore(solution[curr ^ 1], global + ivec2(1, 1), vec4(cacheLoadValue(local + ivec2(1, 1))));
	}
}
